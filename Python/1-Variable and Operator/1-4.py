# 列表的可变和元组的不可变

a = 3 / 2
# 这个是直接除
a = 3 // 2
# 这个是整除
c = 3 % 2
# 求余数
d = 2 ** 5
# 求次方运算

# 元组和列表也可以比较

'''
and 和 or的返回规律
模拟一下计算机解析代码的流程
1 and 0  读到1的时候不能把这个结果输出？ 不行，因为一个是读不出来的，一定要有两个才行 因为and两个同时为真才出真。
1 and 2 首先计算的结果一定是真的，刚才讲的因为第一个是真所以只有知道了第二个是什么才可以返回，所以就直接返回第二个数字2（数据堆栈）

or 0 or 1 输出1
1 or 0 返回1， 既然是真就直接返回了1 
1 or 2 直接返回 1 

1 or 2 and 3 返回 1  and 的优先级高于 or
'''

print(1 and 0)
print(1 or 0)
print('a' and 'b')

a = 1
print(a in [1, 2, 3, 4])

# 字典的成员运算符 这个只看key不看value
b = 'a'

# == 和 is的区别
a = 787878
b = 787878
print(1 == 1.0)
print(1 is 1.0)
print('----------------')
print(a is b)
'''
== 比较的是值是否相等 is比较的是身份是否相等，也就是说他们的地址是否一致
a = {1,2,3} b = {2,1,3} a == b True               a is b False 
原因： 集合时无序的只考虑成员就行了，但是内存地址是不一样的
c = (1,2,3) d = (2,1,3) c == d False c is d False
原因： 元组是由顺序的，顺序不一样是不一样的。
 
'''

'''
判断一个对象的类型： 
1. type(a) == int  但是这个方法不能判断子类型的，只能是当前类型
2. isinstance(a, int)
    2.1 isinstance(a,(int, str, float)) 返回是否是元组中的任何一个类型
    
对象的三个特征： id value type
'''

'''
& 按位与
| 按位或
^ 按位异或
~ 按位取反
把数字当作二进制数进行运算

'''
